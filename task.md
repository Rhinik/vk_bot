# Task
* Create useful and comfortable python module to write scripts that works with VK API
* Structed by decorators, like @chat means. that code will be work only in chat, @from_user means code will react only to users

# Examples
```python
from vk_bot import (
        Auth, peer
    )
import db # Some database

api, handler = Auth(
        token="token",
        v=5.103,
        group_id=12345
    )

lp = handler.LongPoll()

@db.users.mute(False)
@verified(False)
@has_followers(1000)
@gender.male
@older(16)
@subscribed(True)
@path.direct()
@lp.message_new()
def hello(event, pl):
    """
    Will answer, if will come new message in direct
    from user that followed to the group, older than 16,
    is male, has more than 1000 followers, has
    no verified page and value of `mute` in database is False
    """

    api.messages.send(
        peer_id=event.object.message.from_id,
        message=f"""
        Hello, how are you?
        I think, your user_id is {event.object.message.from_id}
        """,
        random_id=0
    )

if __name__ == '__main__':
    lp() ## Should be args
```

# Реализация возможности декорирования
> Почему вообще над этим стоит заострять внимание? Я хочу сделать так, чтобы обратотка события не уступала обычной ветке условий, но и выигрывала в этом

> И еще одно отступление -- в контексте моего пакета декоратор для реакций имеют немного другую суть, нежели то, как он используется обычно. Это не совсем _фабрика_ новых функций, это скорее предварительные ~ласки~ проверки. Они __не__ создают новую функцию, а лишь являются атрибутом уже созданной. Сама суть подобного декоратора используется из-за синтаксического сахара. Только из-за возможности не награмождать ваш код условиями для исполнения (что в ботах для вк используется __постоянно__), а вынести все в это в некую _пачку_ и просто поместить _над_ функцией.

Прежде всего важно понять, что любая реакция (функция) будет в первую очередь обернута декоратором на лонпулл, т.е. каждая реакция __всегда будет иметь обрабатываемое событие, как свое начало__, в отличие от любых других, которые будут распологаться __выше__ и __глубже__ в иерархической структуре условий, причем если докератор на лонгпулл будет иметь каждая функция, то определенные декораторы, например @direct, который отвечает за обработку сообщений в лс -- не у всех.

## Что мы имеем?
> Этот вопрос мы зададим не раз, пока будем разбираться. Поверь.

Весь хэндл по поиску нужной реакции на событие будет происходить сразу после получения события. Если события, на которые есть у всех -- то можно составить словарь с ключами в виде имени события и значением в виде списка с возможными реакциями. Предварительно для каждой такой группы нужно найти пересекающиеся декораторы (а это значит, что декораты буду выступать в роли атрибута объекта функции). Так ли это будет выглядеть?
```python
reactions = {
    'message_new': [
        func1, func2, func3
    ],
    'wall_post_new': [
        func4
    ],
    'group_join': [
        funcN
    ]
}
```
Допустим, что мы словили message_new, обработали, и поняли, что у нас есть 3 фукнции (func1,2,3). Если нам нужно знать, под какие декораторы обернута функция -- значит наша реакция должна у себя в свойствах иметь список с этими самыми декораторами, которые уже заранее взяты. Но как? Идем дальше

## Почему if-ы -- проигрышный вариант?
Для начала, разебрем саму ветку if-elif. На каждое из ветвей уже выделен определенный кусок кода. Если этот кусок кода состоит из нескольких функций -- if-у не нужно проверять условие перед каждой функцией. If проверил это единожды и получил свой код. И где же здесь минусы? Зачастую ради упрощения понимания веток кода приходится __повторять одни и те же if в сестрицких ветках__. Допустим, у вас есть та же ветка if-elif, которая сравнивает первое слово с командой и потом выполняет какой-то код. И вот вы решили добавить какую-то проверку, еще одну и еще, а где-то нужно добавить частично. И вот перед вами выбор -- повторяться в условиях среди сестрицких ветках или же сделать полную кашу в условиях, но при этом минимизировать повторения? Именно в этом и есть главная задача этого пакета -- переложить распределение разной сложности вложенных веток if на python. Если с теоритической частью все ясно -- то же с практической? Как такое реализовать?
## Техническая часть
При предствалении самой реализации возникает несколько проблем:
* Один и тот же декоратор может использвоаться с разными значениями или вообще не использоваться
* Декраторы могут распологаться в разном порядке, что влияет на исполнение кода.

### По порядку
#### Первый и последний
Первым декоратором является обработчки lp. Именно он задает event в функцию при ее вызове, но вызвать он ее может лишь только после обработки другими декораторами. Другими словами -- @lp.event_name хэндлит выполнение реакции и ее не выполнение от начала до конца.
#### Важен ли порядок декораторов?
Придавать значение всем другим декораторам по их месторасположению создает проблему. Поэтому их расположение не должно играть никак роли (кроме самом первого).
#### А как же полезная нагрузка?
Имея опыт в разработке вкшных ботов, скажу сразу -- всегда пишешь какие-то оболочки и оберкти под прилетающие события вк, чтобы их легче было обрабатывать. Зачастую это объекты пользователя, совмещающие данные с вк и данные с бд, обработчики команд и всякая удобная всячина. Поэтому и здесь я решил добавть отдельные аргумент для таких функций -- pl (payload). Чтобы не создавать отдельный декоратор и не нагромождать их, функция, создающая pl, должна быть передана в аргумент для @lp. То есть:
```python
@lp.message_new(pl=payload_init_function)
def reaction(event, pl):
    # some code
```
как это работает под капотом -- разберемся чуть позже
### Что парсить?
Если пробелма с порядком деократоров может быть решена, то что насчет их использования или неиспользвания? Как тогда парсер найдет ту самую нужую функцию? Сразу можно выдвинуть факт: если декоратор не указан -- значит условие этого декоратора всегда будет истинным, что играет нам на руку. Что имеем? Назовем группой -- реакции, отвечающие на одинаковые события. Если же гурппа имеет повторяющиеся условия исполнения -- значит они условно находятся в одной ветке if. Если они они обернуты одинаковыми декораторами, но с разными условиями -- это сестрицкие ветки. Если же одни имеют, а другие нет -- значит та реакция, у которой этот декоратор не найден автоматически под его условием имеем истину. То есть эта функция лежит вне ветки if.
### Создание веток
Со словарем, где кючи -- имена событий, разобрались. Что внутри? Но перед чаналом разберем суть if-elif: результат в _примитивных условиях_ может быть истинным только в 1 одном случае. Допустим, у нас что-то подобное
```python
@prefix('/')
@path.chat()
@lp.message_new()
def func1(event, pl):
    print(1)

@path.chat()
@lp.message_new()
def func2(event, pl):
    print(2)

@path.direct()
@prefix('.')
@lp.message_new()
def func3(event, pl):
    print(3)
```
Имеем вот такой словарь, это однозначно
```python
reactions = {
    'message_new': ... # Но что здесь?
}
```
У нас есть две функции, которые работают в беседе и одна в лс. Две ветки для if-elif. Мы имеем два одинаковых декоратора с одинаковыми условиями на проверку. Соотвественно, мы должны проверить его единожды и получить сразу две функции, при этом исключить 1 (тк она в лс), либо наоборот. Тупик... Я не хочу делать создание своих декораторов тяжелой работой и их понимание оставить в такой же просто форме, при этом сделать так, чтобы эта структура не уступала if-ветке. Неужели единственный выход -- проработать все известные декораторы а уже потом разобраться? Нет.
динственный параметр, который нужно задать декоратору дополнительно -- исключение остальных значений при несоответствии. По итогу -- мы должно создать класс, реализующий `__call__`. Сделаем набросок функции, которую мы должны сделать.
```python
def path():

```
